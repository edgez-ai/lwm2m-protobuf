// -----------------------------------------------------------------------------
// LwM2M Protobuf Schema (Skeleton)
// -----------------------------------------------------------------------------
// This file defines a starting point for representing Lightweight M2M (LwM2M)
// operations, registration lifecycle, resource addressing, observe/notify, and
// generic request/response messaging over a gRPC or other protobuf-capable
// transport.
//
// Customize: package name, go/java/csharp options, enum values you actually
// intend to support, services (if you will expose gRPC), and the message shapes
// to match your gateway/server/device architecture.
// -----------------------------------------------------------------------------

syntax = "proto3";

package lwm2m; // Change to your org namespace (e.g., edgez.lwm2m)

option optimize_for = SPEED;
// Language-specific (uncomment & adapt)
// option go_package = "github.com/yourorg/yourrepo/lwm2m/pb;lwm2mpb";
option java_multiple_files = true;
option java_package = "ai.edgez.lwm2m";
option java_outer_classname = "LwM2MProto";
// option csharp_namespace = "YourOrg.LwM2M";


// (device)appearance broadcasting => (gateway)device discovery => (device) challenge => (device) challenge answer => (server) bootstrap => (device) bootstrap

message LwM2MMessage {
	string serial = 1;
    oneof body {
		// Future message types here
		bytes encrypted_data = 100;  // inside is encrypted protobuf message
    }
}

message LwM2MDevice {
	sint32 model = 1;
	uint32 serial = 2; // also same meaning for node_id in mesh network
	bytes public_key = 3; // client public key
	bytes aes_key = 4; // symmetric key for AES-256-GCM
}

message LwM2MDeviceMap {
	map<uint32, LwM2MDevice> devices = 1;
}

// when send challenge to device, will get raw encrypted bytes back
message LwM2MDeviceChallenge {
	uint32 nounce = 1; // random transaction id generated by server
	bytes public_key = 2; // presigned signature using trusted private key, and encrypted using ECDH + ChaCha20-Poly1305
}

message LwM2MDeviceChallengeAnswer {
	bytes public_key = 1; // presigned signature using trusted private key, and encrypted using ECDH + ChaCha20-Poly1305
	bytes signature = 2; // signature of the above fields using device private key
}


enum LwM2MBootstrapResultCode {
	UNSPECIFIED = 0;
	SUCCESS = 1;
	INVALID_SIGNATURE = 2;
	INVALID_MODEL = 3;
	INVALID_SERIAL = 4;
	OTHER_ERROR = 5;
	DELETED = 6;
	BANNED = 7;
}

// send the request together with gateway PSK as security Guarantee
message LwM2MDeviceBootstrapRequest {
	uint32 model = 1;
	uint32 serial = 2;
	uint32 nounce = 3; // random transaction id generated by server
	bytes encrypted_data = 4; // basically test the encryption method between client and server
}

message LwM2MBootstrapResponse {
	LwM2MBootstrapResultCode code = 1;
	uint32 nounce = 2; // the same nounce as in request
	bytes payload = 3; // presigned signature using trusted private key, and encrypted using ECDH + ChaCha20-Poly1305, the payload is serialized LwM2MDeviceBootstrap, only send this part to device
}

message LwM2MDeviceBootstrap {
	uint32 pin = 1; // must be the same as on the device
	uint32 instance_id = 2; // unique per cluster
	bytes admin_key = 3; // per device admin key
	bytes aes_key = 4; // advertise data will be encrypted using this key
	// some extra configuration here
}

message LwM2MResourceGet {
	sint32 object_id = 1;
	sint32 resource_id = 2;
	sint32 resource_instance_id = 3;
	oneof value {
		bytes bytes_value = 4;
		string string_value = 5;
		sint32 int_value = 6;
		bool bool_value = 7;
		float float_value = 8;
		double double_value = 9;
	}
}

message LwM2MResourceSet {
	sint32 object_id = 1;
	sint32 resource_id = 2;
	sint32 resource_instance_id = 3;
	oneof value {
		bytes bytes_value = 4;
		string string_value = 5;
		sint32 int_value = 6;
		bool bool_value = 7;
		float float_value = 8;
		double double_value = 9;
	}
}

message FactoryPartition {
	string serial = 1;
	sint32 pin = 2; // pin code for provisioning
	bytes public_key = 3; // client public key
	bytes private_key = 4; // client private key
	bytes bootstrap_server = 5; // bootstrap server URL
	bytes signature = 6; // signature of the above fields using factory private key
	bytes signature_cert = 7; // certificate of the factory public key
}